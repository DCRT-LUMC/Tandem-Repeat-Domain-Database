<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Detail - TandemSkip</title>
    <!-- Add favicon links -->
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://3Dmol.org/build/3Dmol-min.js"></script>
    <!-- Add Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Add Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --secondary: #3f37c9;
            --accent: #4cc9f0;
            --success: #4ade80;
            --danger: #f87171;
            --warning: #facc15;
            --info: #60a5fa;
            --dark: #1e293b;
            --light: #f8fafc;
            --gray: #94a3b8;
            --bg-color: #ffffff;
            --card-bg: #ffffff;
            --border-radius: 12px;
            --box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --transition: all 0.3s ease;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--dark);
            line-height: 1.6;
        }
        
        .viewer-title {
            background-color: var(--light);
            padding: 16px 24px;
            border-left: 4px solid var(--primary);
            margin-bottom: 24px;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            box-shadow: var(--box-shadow);
        }
        
        .viewer-title h2 {
            font-weight: 700;
            margin-bottom: 4px;
            color: var(--primary);
        }
        
        .protein-info {
            display: flex;
            justify-content: space-between;
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 24px;
            box-shadow: var(--box-shadow);
            flex-wrap: wrap;
            gap: 16px;
        }
        
        /* 3D viewer styling */
        #proteinViewer {
            width: 100%;
            height: 450px;
            position: relative;
            margin: 20px 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
            background-color: #f0f4f8;
        }
        
        .viewer-container {
            margin-top: 30px;
        }
        
        .viewer-controls {
            display: flex;
            margin-bottom: 16px;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .view-button {
            padding: 10px 20px;
            background-color: var(--light);
            cursor: pointer;
            border: none;
            border-radius: var(--border-radius);
            font-size: 14px;
            font-weight: 500;
            color: var(--dark);
            transition: var(--transition);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .view-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .view-button.active {
            background-color: var(--primary);
            color: white;
        }
        
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 24px;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: var(--box-shadow);
            z-index: 100;
            min-width: 200px;
        }
        
        .viewer-legend {
            margin-top: 16px;
            padding: 16px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            box-shadow: var(--box-shadow);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            background-color: var(--light);
            padding: 8px 12px;
            border-radius: 30px;
            transition: var(--transition);
        }
        
        .legend-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.05);
        }
        
        .back-button {
            margin-bottom: 24px;
        }
        
        .back-button a {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 30px;
            background-color: var(--light);
            color: var (--dark);
            font-weight: 500;
            transition: var(--transition);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .back-button a:hover {
            background-color: var(--primary-light);
            color: white;
            transform: translateX(-4px);
        }
        
        .key-fact {
            background-color: var(--light);
            padding: 10px 16px;
            border-radius: var(--border-radius);
            margin: 10px 0;
            display: inline-block;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .error-container {
            margin: 50px auto;
            max-width: 500px;
            text-align: center;
            padding: 30px;
            background-color: #fee2e2;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }
        
        .genomic-data {
            background-color: var(--card-bg);
            padding: 24px;
            border-radius: var(--border-radius);
            margin-top: 24px;
            box-shadow: var(--box-shadow);
        }

        .exon-legend-item {
            margin-top: 6px;
        }

        /* Styles for section headers and toggles */
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary) 100%);
            padding: 16px 24px;
            margin-bottom: 24px;
            border-radius: var(--border-radius);
            color: white;
            box-shadow: var(--box-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .section-header h3 {
            margin: 0;
            font-weight: 600;
            font-size: 1.25rem;
            position: relative;
            z-index: 1;
        }
        
        .section-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            opacity: 0.3;
        }
        
        .toggle-button {
            padding: 6px 12px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.875rem;
            color: white;
            transition: var (--transition);
            backdrop-filter: blur(2px);
            position: relative;
            z-index: 1;
        }
        
        .toggle-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        .collapsible-content {
            overflow: hidden;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            margin-bottom: 24px;
            transition: var(--transition);
        }
        
        .collapsed {
            display: none;
        }
        
        .external-links {
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .external-link-btn {
            font-size: 0.875rem;
            padding: 6px 12px;
            text-decoration: none;
            color: var(--primary);
            background-color: rgba(67, 97, 238, 0.1);
            border-radius: 20px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: var (--transition);
        }
        
        .external-link-btn:hover {
            background-color: var(--primary);
            color: white;
            transform: translateY(-2px);
        }
        
        /* Table styling */
        .table {
            margin-bottom: 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05);
        }
        
        .table thead th {
            background-color: var(--primary-light);
            color: white;
            font-weight: 500;
            border: none;
        }
        
        .table-striped tbody tr:nth-of-type(odd) {
            background-color: rgba(0, 0, 0, 0.02);
        }
        
        /* Loading spinner */
        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.25rem;
            color: var (--primary);
        }
        
        /* Specific card containers for repeat and genomic info */
        .summary-card, .genomic-card {
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 24px;
            box-shadow: var(--box-shadow);
        }
        
        /* Footer styling */
        footer {
            margin-top: 40px;
            padding: 24px 0;
            text-align: center;
            color: var(--gray);
            font-size: 0.875rem;
        }
        
        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #proteinDetails {
            animation: fadeIn 0.5s ease-out;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .protein-info {
                flex-direction: column;
            }
            
            .viewer-controls {
                justify-content: center;
            }
            
            .section-header {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="back-button">
        <a href="index.html" class="btn btn-outline-secondary btn-sm">
            <i class="fas fa-arrow-left"></i> Back to Protein List
        </a>
    </div>
    
    <div id="loading" class="text-center my-5">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3">Loading protein data...</p>
    </div>
    
    <div id="errorContainer" style="display: none;" class="error-container">
        <h4>Error</h4>
        <p id="errorMessage">Unable to load protein data</p>
        <a href="index.html" class="btn btn-primary mt-3">Return to Protein List</a>
    </div>
    
    <div id="proteinDetails" style="display: none;">
        <div class="viewer-title">
            <h2>TandemSkip Detail Viewer</h2>
            <p id="proteinTitle" class="mb-0">Protein Structure</p>
        </div>
        
        <div class="protein-info">
            <div>
                <div class="d-flex align-items-center mb-2">
                    <i class="fas fa-id-card me-2 text-primary"></i>
                    <strong>UniProt:</strong> 
                    <a id="uniprotLink" target="_blank" class="ms-2 text-decoration-none"></a>
                </div>
                <div class="d-flex align-items-center mb-2">
                    <i class="fas fa-dna me-2 text-primary"></i>
                    <strong>Gene:</strong> 
                    <span id="geneName" class="ms-2"></span>
                </div>
                <div class="external-links">
                    <a id="ensemblLink" href="#" target="_blank" class="external-link-btn">
                        <i class="fas fa-external-link-alt"></i> Ensembl
                    </a>
                    <a id="genecardsLink" href="#" target="_blank" class="external-link-btn">
                        <i class="fas fa-external-link-alt"></i> GeneCards
                    </a>
                    <a id="pdbLink" href="#" target="_blank" class="external-link-btn">
                        <i class="fas fa-external-link-alt"></i> PDB
                    </a>
                </div>
            </div>
            <div>
                <div class="d-flex align-items-center mb-2">
                    <i class="fas fa-sync-alt me-2 text-primary"></i>
                    <strong>Repeat Type:</strong> 
                    <span id="repeatType" class="ms-2 badge bg-info"></span>
                </div>
                <div class="d-flex align-items-center">
                    <i class="fas fa-info-circle me-2 text-primary"></i>
                    <strong>Status:</strong> 
                    <span id="status" class="ms-2 badge bg-success"></span>
                </div>
            </div>
        </div>
        
        <!-- Add 3D Viewer Container -->
        <div class="section-header">
            <h3><i class="fas fa-cube me-2"></i>3D Structure Visualization</h3>
            <button class="toggle-button" onclick="toggleSection('viewerContainer')">
                <i class="fas fa-eye-slash me-1"></i> Hide
            </button>
        </div>
        <div id="viewerContainer" class="viewer-container collapsible-content">
            <div class="viewer-controls">
                <button class="view-button active" id="highlightRepeatsBtn">
                    <i class="fas fa-highlighter me-1"></i> Highlight Repeats
                </button>
                <button class="view-button" id="standardViewBtn">
                    <i class="fas fa-atom me-1"></i> Standard View
                </button>
                <button class="view-button" id="zoomRepeatsBtn">
                    <i class="fas fa-search-plus me-1"></i> Zoom to Repeats
                </button>
                <button class="view-button" id="exonBoundariesBtn">
                    <i class="fas fa-project-diagram me-1"></i> Show Exon Boundaries
                </button>
            </div>
            <div id="proteinViewer">
                <div class="loading-indicator">
                    <div class="spinner-border text-primary" style="width: 2rem; height: 2rem;"></div>
                    <p class="mt-2 mb-0">Loading protein structure...</p>
                </div>
            </div>
            <div id="viewerLegend" class="viewer-legend">
                <div class="legend-item">
                    <div class="color-box" style="background-color: #cccccc;"></div>
                    <span>Non-repeat regions</span>
                </div>
            </div>
        </div>
        
        <div class="section-header mt-4">
            <h3><i class="fas fa-layer-group me-2"></i>Summary of Tandem Repeats</h3>
            <button class="toggle-button" onclick="toggleSection('summaryContent')">
                <i class="fas fa-eye-slash me-1"></i> Hide
            </button>
        </div>
        <div id="summaryContent" class="collapsible-content">
            <p id="repeatSummary" class="lead"></p>
            <ul id="repeatList" class="list-group list-group-flush mt-3"></ul>
            
            <!-- Publication section removed -->
        </div>
        
        <div class="section-header mt-4">
            <h3><i class="fas fa-dna me-2"></i>Genomic Information</h3>
            <button class="toggle-button" onclick="toggleSection('genomicContent')">
                <i class="fas fa-eye-slash me-1"></i> Hide
            </button>
        </div>
        <div id="genomicContent" class="collapsible-content">
            <div class="row mb-3">
                <div class="col-md-6">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-chromosome me-2 text-primary"></i>
                        <strong>Chromosome:</strong> 
                        <span id="chromosome" class="ms-2 badge bg-secondary"></span>
                    </div>
                    <div class="d-flex align-items-center">
                        <i class="fas fa-map-marker-alt me-2 text-primary"></i>
                        <strong>Genomic Range:</strong> 
                        <span id="genomicRange" class="ms-2"></span>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-arrows-alt-h me-2 text-primary"></i>
                        <strong>Strand:</strong> 
                        <span id="strand" class="ms-2"></span>
                    </div>
                    <div class="d-flex align-items-center">
                        <i class="fas fa-tags me-2 text-primary"></i>
                        <strong>Aliases:</strong> 
                        <span id="aliases" class="ms-2"></span>
                    </div>
                </div>
            </div>
            <div id="exonSummary" class="mt-4">
                <h4 class="d-flex align-items-center mb-3">
                    <i class="fas fa-puzzle-piece me-2 text-primary"></i>
                    Exon Information
                </h4>
                <div id="exonDataText" class="table-responsive">Loading exon data...</div>
            </div>
        </div>
    </div>
    
    <footer class="bg-light mt-5 py-3">
        <div class="container text-center">
            <p class="mb-0">
                <i class="fas fa-database me-1"></i>
                TandemSkip - <span class="text-primary">Dynamically generated from JSON data</span>
            </p>
        </div>
    </footer>
    
    <script>
        // Global variables - add at the top of your script
        let processedExonData = null; // Store exon data globally once processed
        let viewer = null;
        let originalRepeatRegions = []; // Store original repeat data
        let processedRepeatRegions = []; // Store processed repeat regions
        let viewerInitialized = false; // Track if viewer is fully initialized

        function fetchProteinData(uniprotId, dataUrl) {
            fetch(dataUrl)
                .then(response => response.json())
                .then(data => {
                    // Filter repeats for this protein
                    const proteinRepeats = data.filter(item => item.uniProtId === uniprotId);
                    
                    if (!proteinRepeats.length) {
                        showError(`No data found for protein ${uniprotId}`);
                        return;
                    }
                    
                    console.log(`Found ${proteinRepeats.length} repeats for protein ${uniprotId}`);
                    
                    // Store all raw repeats globally
                    originalRepeatRegions = proteinRepeats;
                    
                    // Process and display the protein data
                    processProteinData(proteinRepeats);
                    
                    // Process exon data only once - Fix the undefined function error
                    const exonData = extractExonData(proteinRepeats);
                    if (exonData) {
                        processedExonData = exonData;
                        updateExonDisplay(exonData);
                        console.log("Successfully extracted and processed exon data");
                    } else {
                        console.log("No exon data found or extraction failed");
                        document.getElementById('exonDataText').textContent = 
                            "No exon data available for this protein or the repeat regions.";
                    }
                    
                    // Hide the main loading indicator
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('proteinDetails').style.display = 'block';
                })
                .catch(error => {
                    console.error('Error loading data:', error);
                    showError("Error loading protein data");
                });
        }
        
        // Debug function to check for ensembl_exon_info key
        function verifyExonData(repeats) {
            let hasExonInfo = false;
            let keyName = null;
            
            repeats.forEach((repeat, i) => {
                const keys = Object.keys(repeat);
                if (keys.includes('ensembl_exon_info')) {
                    hasExonInfo = true;
                    keyName = 'ensembl_exon_info';
                    console.log(`Found exon data in repeat ${i} with key 'ensembl_exon_info'`);
                }
            });
            
            console.log(`Exon data check: ${hasExonInfo ? 'FOUND with key ' + keyName : 'NOT FOUND'}`);
            
            if (!hasExonInfo) {
                // Check for other possible keys
                const sampleKeys = Object.keys(repeats[0] || {});
                console.log("Available keys:", sampleKeys);
                
                // Try looking for keys containing "exon"
                const possibleExonKeys = sampleKeys.filter(key => key.toLowerCase().includes('exon'));
                if (possibleExonKeys.length > 0) {
                    console.log("Possible exon data keys:", possibleExonKeys);
                }
            }
            
            return hasExonInfo;
        }

        function processProteinData(repeats) {
            try {
                // Sort repeats by their position
                repeats.sort((a, b) => {
                    const getStart = r => r.protein_start || 
                        (r.position && r.position.match(/amino acids (\d+)-(\d+)/) ? 
                         parseInt(r.position.match(/amino acids (\d+)-(\d+)/)[1]) : 0);
                    
                    return getStart(a) - getStart(b);
                });
                
                // Get basic protein info from first repeat
                const firstRepeat = repeats[0];
                const proteinInfo = {
                    uniProtId: firstRepeat.uniProtId,
                    geneName: firstRepeat.geneName || 'Unknown',
                    repeatType: firstRepeat.repeatType || 'Unknown',
                    status: firstRepeat.status || 'Unknown',
                    chrom: firstRepeat.chrom || 'Unknown',
                    strand: firstRepeat.strand || 'Unknown',
                    aliases: firstRepeat.aliases || []
                };
                
                // Extract genomic range
                if (repeats.length > 0) {
                    const chromStarts = repeats.map(r => r.chromStart).filter(s => s !== undefined);
                    const chromEnds = repeats.map(r => r.chromEnd).filter(e => e !== undefined);
                    
                    if (chromStarts.length > 0 && chromEnds.length > 0) {
                        const minStart = Math.min(...chromStarts);
                        const maxEnd = Math.max(...chromEnds);
                        proteinInfo.genomicRange = `${minStart}-${maxEnd}`;
                    }
                }
                
                // Extract repeat regions with positions
                const repeatRegions = [];
                repeats.forEach((repeat, index) => {
                    // Use direct protein_start and protein_end fields instead of parsing position
                    const start = repeat.protein_start;
                    const end = repeat.protein_end;
                    
                    if (start && end) {
                        const length = end - start + 1;
                        
                        // Create a color based on index
                        const colorOptions = ["#ff5f5f", "#5fba7d", "#5f87ff", "#ffaf5f", "#bf5fff", "#dc3545", "#fd7e14", "#ffc107", "#20c997", "#0dcaf0"];
                        const color = colorOptions[index % colorOptions.length];
                        const colorHex = color.replace("#", "0x");
                        
                        repeatRegions.push({
                            start,
                            end,
                            length,
                            color,
                            colorHex,
                            position: repeat.position, // Keep for backward compatibility
                            ensembl_exon_info: repeat.ensembl_exon_info,
                            chromStart: repeat.chromStart,
                            chromEnd: repeat.chromEnd,
                            label: `${repeat.repeatType}${index + 1}`
                        });
                    } else {
                        // Fallback to parsing position if direct fields are not available
                        const posMatch = repeat.position && repeat.position.match(/amino acids (\d+)-(\d+)/);
                        if (posMatch) {
                            const start = parseInt(posMatch[1]);
                            const end = parseInt(posMatch[2]);
                            const length = end - start + 1;
                            
                            // Create a color based on index
                            const colorOptions = ["#ff5f5f", "#5fba7d", "#5f87ff", "#ffaf5f", "#bf5fff", "#dc3545", "#fd7e14", "#ffc107", "#20c997", "#0dcaf0"];
                            const color = colorOptions[index % colorOptions.length];
                            const colorHex = color.replace("#", "0x");
                            
                            repeatRegions.push({
                                start,
                                end,
                                length,
                                color,
                                colorHex,
                                position: repeat.position,
                                ensembl_exon_info: repeat.ensembl_exon_info,
                                chromStart: repeat.chromStart,
                                chromEnd: repeat.chromEnd,
                                label: `${repeat.repeatType}${index + 1}`
                            });
                        }
                    }
                });
                
                // Store the processed repeat regions globally
                processedRepeatRegions = repeatRegions;

                // Check for exon data
                verifyExonData(originalRepeatRegions);

                // Display the protein information
                displayProteinInfo(proteinInfo, repeatRegions);
                
                // Set up the 3D viewer
                initializeViewer(proteinInfo.uniProtId, repeatRegions);
                
            } catch (error) {
                console.error("Error processing protein data:", error);
                showError("Error processing protein data");
            }
        }
        
        function displayProteinInfo(info, repeats) {
            // Update the UI with protein information
            document.getElementById('proteinTitle').textContent = 
                `Focused view of ${info.repeatType} repeat domains in protein ${info.uniProtId} (${info.geneName})`;
                
            document.getElementById('uniprotLink').textContent = info.uniProtId;
            document.getElementById('uniprotLink').href = `https://www.uniprot.org/uniprotkb/${info.uniProtId}`;
            
            document.getElementById('geneName').textContent = info.geneName;
            document.getElementById('repeatType').textContent = info.repeatType;
            document.getElementById('status').textContent = info.status;
            
            // Genomic information
            document.getElementById('chromosome').textContent = info.chrom;
            document.getElementById('strand').textContent = info.strand === '+' ? 'Forward (+)' : 'Reverse (-)';
            document.getElementById('genomicRange').textContent = info.genomicRange || 'Not available';
            document.getElementById('aliases').textContent = Array.isArray(info.aliases) ? 
                info.aliases.join(', ') : (info.aliases || 'None');
            
            // Update repeat summary
            document.getElementById('repeatSummary').textContent = 
                `Protein ${info.uniProtId} (${info.geneName}) contains ${repeats.length} ${info.repeatType} repeats in positions:`;
            
            // Create repeat list items
            const repeatList = document.getElementById('repeatList');
            repeatList.innerHTML = '';
            repeats.forEach(repeat => {
                const li = document.createElement('li');
                li.textContent = `${repeat.start}-${repeat.end} (${repeat.length} amino acids)`;
                repeatList.appendChild(li);
            });
            
            // Create legend for repeats
            createLegend(repeats);

            // Add external resource links
            const ensemblLink = document.getElementById('ensemblLink');
            ensemblLink.href = `https://www.ensembl.org/Homo_sapiens/Search/Results?q=${info.geneName}`;
            
            const genecardsLink = document.getElementById('genecardsLink');
            genecardsLink.href = `https://www.genecards.org/cgi-bin/carddisp.pl?gene=${info.geneName}`;
            
            const pdbLink = document.getElementById('pdbLink');
            pdbLink.href = `https://www.rcsb.org/search?query=${info.uniProtId}`;
        }
        
        function createLegend(repeats) {
            const legend = document.getElementById('viewerLegend');
            
            // Clear existing items except the "Non-repeat regions"
            while (legend.childNodes.length > 1) {
                legend.removeChild(legend.firstChild);
            }
            
            // Add legend items for each repeat
            repeats.forEach((repeat, index) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = repeat.color;
                
                const label = document.createElement('span');
                label.textContent = `${repeat.label} (${repeat.start}-${repeat.end})`;
                
                item.appendChild(colorBox);
                item.appendChild(label);
                
                // Insert at the top
                legend.insertBefore(item, legend.firstChild);
            });
        }
        
        function initializeViewer(uniprotId, repeatRegions) {
            // Get PDB URL for this protein
            const pdbPath = `https://alphafold.ebi.ac.uk/files/AF-${uniprotId}-F1-model_v4.pdb`;
            
            // Initialize the 3D structure viewer using 3Dmol.js
            const proteinViewerElement = document.getElementById('proteinViewer');
            
            // Initialize the 3Dmol viewer and load the model
            viewer = $3Dmol.createViewer(proteinViewerElement, {
                backgroundColor: "white",
                antialias: true,
                powerPreference: "high-performance"
            });
            
            // Check AlphaFold first, then fall back to local
            $.ajax({
                url: pdbPath,
                success: function(data) {
                    loadModel(data);
                },
                error: function() {
                    // Fall back to local file
                    $.ajax({
                        url: `../data/AF-${uniprotId}-F1-model_v4.pdb`,
                        success: function(data) {
                            loadModel(data);
                        },
                        error: function(xhr, status, error) {
                            const loadingIndicator = document.querySelector('.loading-indicator');
                            if (loadingIndicator) {
                                loadingIndicator.textContent = `Error loading structure: Model not available for ${uniprotId}`;
                            }
                            console.error("Failed to load PDB file:", error);
                        }
                    });
                }
            });
            
            function loadModel(data) {
                try {
                    // Hide loading indicator once the model is loaded
                    const loadingIndicator = document.querySelector('.loading-indicator');
                    if (loadingIndicator) {
                        loadingIndicator.style.display = 'none';
                    }
                    
                    // Add the model to the viewer
                    let model = viewer.addModel(data, "pdb");
                    
                    // Use the already processed repeat regions (don't reprocess)
                    const repeatRegions = processedRepeatRegions;
                    
                    // No need to extract exon data again, use the globally processed data
                    // Just log repeat info for debugging
                    logRepeatRegionsInfo(originalRepeatRegions);
                    
                    // Apply the repeats highlight by default
                    highlightRepeats();
                    
                    // Zoom directly to the repeat regions if any
                    if (repeatRegions.length > 0) {
                        const firstRepeat = repeatRegions[0].start;
                        const lastRepeat = repeatRegions[repeatRegions.length - 1].end;
                        viewer.zoomTo({resi: `${firstRepeat}-${lastRepeat}`});
                    }
                    
                    // Rotate to a good angle for viewing repeats
                    viewer.rotate(30, {x: 1});
                    viewer.rotate(20, {y: 1});
                    
                    // Check if enableSlabbing is available before calling it
                    if (typeof viewer.enableSlabbing === 'function') {
                        viewer.enableSlabbing();
                    } else {
                        console.log("enableSlabbing function not available in this version of 3Dmol.js");
                    }
                    
                    viewer.render();
                    console.log("3D model successfully loaded and rendered");
                    
                    // Set viewer as initialized after loading completes
                    viewerInitialized = true;
                    
                    // Apply the repeats highlight by default - this is already done but ensure it works
                    setTimeout(() => {
                        // Execute after a short delay to ensure the viewer is fully ready
                        highlightRepeats();
                        
                        // Set active class on highlight repeats button
                        document.getElementById('highlightRepeatsBtn').classList.add('active');
                        
                        // Zoom to repeats area initially
                        if (repeatRegions.length > 0) {
                            const firstRepeat = repeatRegions[0].start;
                            const lastRepeat = repeatRegions[repeatRegions.length - 1].end;
                            viewer.zoomTo({resi: `${firstRepeat}-${lastRepeat}`});
                        }
                    }, 100);
                } catch (error) {
                    console.error("Error in loadModel function:", error);
                    const loadingIndicator = document.querySelector('.loading-indicator');
                    if (loadingIndicator) {
                        loadingIndicator.textContent = "Error loading protein structure";
                    }
                }
            }
        }

        // Highlight the repeat domains specifically
        function highlightRepeats() {
            if (!viewer || !viewerInitialized) {
                console.error("Viewer not initialized yet");
                return;
            }
            
            try {
                // Clear all previous styles and settings
                viewer.removeAllSurfaces();
                viewer.removeAllShapes();
                viewer.removeAllLabels();
                
                // Set whole protein to a light gray surface
                viewer.setStyle({}, {
                    cartoon: {color: '0xcccccc', opacity: 0.5},
                    surface: {opacity: 0.6, color: '0xdddddd'}
                });
                
                // Use the globally stored processed repeat regions instead of extracting from DOM
                const repeatRegions = processedRepeatRegions;
                
                if (!repeatRegions || repeatRegions.length === 0) {
                    console.warn("No repeat regions found");
                    viewer.render();
                    return;
                }
                
                // Highlight each repeat with colored surface
                repeatRegions.forEach(repeat => {
                    const selection = {resi: `${repeat.start}-${repeat.end}`};
                    
                    viewer.setStyle(selection, {
                        cartoon: {color: repeat.colorHex, opacity: 1.0},
                        surface: {opacity: 0.8, color: repeat.colorHex}
                    });
                    
                    // Add label
                    viewer.addLabel(repeat.label, {
                        position: {resi: Math.floor((repeat.start + repeat.end) / 2)},
                        backgroundColor: 'black',
                        backgroundOpacity: 0.7,
                        fontColor: 'white',
                        fontSize: 12
                    });
                });
                
                viewer.zoomTo();
                viewer.render();
            } catch (error) {
                console.error("Error in highlightRepeats:", error);
            }
        }
        
        // Show standard view (cartoon representation)
        function showStandardView() {
            if (!viewer || !viewerInitialized) {
                console.error("Viewer not initialized yet");
                return;
            }
            
            try {
                // Clear all previous styles
                viewer.removeAllSurfaces();
                viewer.removeAllShapes();
                viewer.removeAllLabels();
                
                // Reset all styles first
                viewer.setStyle({}, {});
                
                // Color by chain
                viewer.setStyle({}, {cartoon: {colorscheme: 'chainHetatm', thickness: 0.8}});
                
                // Use the globally stored processed repeat regions instead of extracting from DOM
                const repeatRegions = processedRepeatRegions;
                
                if (!repeatRegions || repeatRegions.length === 0) {
                    console.warn("No repeat regions found");
                    viewer.render();
                    return;
                }
                
                // Highlight repeat regions with subtle effect
                repeatRegions.forEach(repeat => {
                    viewer.addStyle({resi: `${repeat.start}-${repeat.end}`}, {
                        cartoon: {opacity: 1.0, thickness: 1.2}
                    });
                });
                
                viewer.zoomTo();
                viewer.render();
            } catch (error) {
                console.error("Error in showStandardView:", error);
            }
        }
        
        // Zoom specifically to the repeat regions
        function zoomToRepeats() {
            if (!viewer || !viewerInitialized) {
                console.error("Viewer not initialized yet");
                return;
            }
            
            try {
                // Use the globally stored processed repeat regions instead of extracting from DOM
                const repeatRegions = processedRepeatRegions;
                
                if (!repeatRegions || repeatRegions.length === 0) {
                    console.warn("No repeat regions found");
                    return;
                }
                
                // First selection includes all repeats to zoom
                const firstRepeat = repeatRegions[0].start;
                const lastRepeat = repeatRegions[repeatRegions.length - 1].end;
                
                // Set the zoom
                viewer.zoomTo({resi: `${firstRepeat}-${lastRepeat}`});
                
                // Rotate to a good angle for viewing repeats
                viewer.rotate(30, {x: 1});
                viewer.rotate(20, {y: 1});
                
                viewer.render();
            } catch (error) {
                console.error("Error in zoomToRepeats:", error);
            }
        }
        
        // Helper to set active button class
        function setActiveButton(button) {
            try {
                document.querySelectorAll('.view-button').forEach(btn => {
                    // Skip the exon button so we don't interfere with its toggle state
                    if (btn.id !== 'exonBoundariesBtn') {
                        btn.classList.remove('active');
                    }
                });
                
                if (button.id !== 'exonBoundariesBtn') {
                    button.classList.add('active');
                }
            } catch (error) {
                console.error("Error in setActiveButton:", error);
            }
        }
        
        // Helper to extract repeat regions from the page - DEPRECATED, NO LONGER USED
        // Keeping for reference but all functions now use processedRepeatRegions directly
        function getRepeatRegionsFromPage() {
            return processedRepeatRegions || [];
        }
        
        // Display error message
        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('errorContainer').style.display = 'block';
            document.getElementById('errorMessage').textContent = message;
        }

        // Function to fetch all protein repeats
        function fetchAllProteinRepeats(uniprotId, dataUrl) {
            return fetch(dataUrl)
                .then(response => response.json())
                .then(data => {
                    // Filter repeats for this protein
                    return data.filter(item => item.uniProtId === uniprotId);
                })
                .catch(error => {
                    console.error('Error loading all repeats:', error);
                    return [];
                });
        }
        
        // Function to extract exon data from all repeats
        function extractExonData(repeatRegions) {
            // Find a canonical transcript across repeats
            const exonData = { transcript: null, exons: [] };
            
            // First check if we have any exon info - store this globally
            let hasExonData = false;
            let exonInfoFound = false;
            
            console.log(`Processing ${repeatRegions.length} repeat regions for exon data`);
            
            for (const repeat of repeatRegions) {
                // Double check what we have in each repeat
                console.log(`Repeat data structure:`, Object.keys(repeat));
                
                if (repeat.ensembl_exon_info && repeat.ensembl_exon_info.transcripts && 
                    repeat.ensembl_exon_info.transcripts.length > 0) {
                    hasExonData = true;
                    exonInfoFound = true;
                    break;
                }
            }
            
            if (!hasExonData) {
                console.log("No exon data found in any repeat regions");
                return null;
            }
            
            // Find canonical transcript
            for (const repeat of repeatRegions) {
                if (!repeat.ensembl_exon_info || !repeat.ensembl_exon_info.transcripts) continue;
                
                const canonical = repeat.ensembl_exon_info.transcripts.find(t => t.is_canonical);
                if (canonical) {
                    exonData.transcript = canonical;
                    console.log("Found canonical transcript:", canonical);
                    break;
                }
            }
            
            // If no canonical found, use first transcript from first repeat with data
            if (!exonData.transcript) {
                for (const repeat of repeatRegions) {
                    if (repeat.ensembl_exon_info && repeat.ensembl_exon_info.transcripts && 
                        repeat.ensembl_exon_info.transcripts.length > 0) {
                        exonData.transcript = repeat.ensembl_exon_info.transcripts[0];
                        console.log("Using non-canonical transcript:", exonData.transcript);
                        break;
                    }
                }
            }
            
            // If no transcript found, return null
            if (!exonData.transcript) {
                console.log("No transcript found in the exon data");
                return null;
            }
            
            // Get transcript ID
            const transcriptId = exonData.transcript.transcript_id;
            console.log(`Using transcript ID: ${transcriptId}`);
            
            // Collect exons from ALL repeats for this protein
            const exonMap = new Map(); // Use map to avoid duplicates
            
            // Go through all repeats to collect their exons
            for (const repeat of repeatRegions) {
                console.log(`Processing repeat at position ${repeat.position || `${repeat.protein_start}-${repeat.protein_end}`}`);
                
                if (!repeat.ensembl_exon_info || !repeat.ensembl_exon_info.transcripts) {
                    console.log("- No exon info in this repeat");
                    continue;
                }
                
                const transcript = repeat.ensembl_exon_info.transcripts.find(t => t.transcript_id === transcriptId);
                if (!transcript || !transcript.containing_exons) {
                    console.log("- No containing exons found for this transcript in this repeat");
                    continue;
                }
                
                // Get the repeat position
                const repeatStart = repeat.protein_start || (repeat.position && repeat.position.match(/amino acids (\d+)-(\d+)/) ? parseInt(repeat.position.match(/amino acids (\d+)-(\d+)/)[1]) : null);
                const repeatEnd = repeat.protein_end || (repeat.position && repeat.position.match(/amino acids (\d+)-(\d+)/) ? parseInt(repeat.position.match(/amino acids (\d+)-(\d+)/)[2]) : null);
                
                if (!repeatStart || !repeatEnd) {
                    console.log("- Could not determine repeat position");
                    continue;
                }
                
                const repeatLabel = repeat.repeatType + (repeatRegions.indexOf(repeat) + 1);
                
                // Process all exons from this repeat
                for (const exon of transcript.containing_exons) {
                    const exonKey = exon.exon_id;
                    console.log(`- Found exon ${exon.exon_number} with ID ${exonKey}`);
                    
                    if (!exonMap.has(exonKey)) {
                        // New exon - add it
                        exonMap.set(exonKey, {
                            exon_number: exon.exon_number,
                            exon_id: exon.exon_id,
                            position: exon.position,
                            coding_status: exon.coding_status || 'Unknown',
                            frame_status: exon.frame_status || 'Unknown',
                            start_phase: exon.phase !== undefined ? exon.phase : 'Unknown',
                            end_phase: exon.end_phase !== undefined ? exon.end_phase : 'Unknown',
                            repeat_regions: [{
                                label: repeatLabel,
                                start: repeatStart,
                                end: repeatEnd
                            }],
                            repeat_start: exon.protein_start,
                            repeat_end: exon.protein_end,
                            overlap_percentage: exon.overlap_percentage,
                            exon_genomic_start: exon.exon_start,
                            exon_genomic_end: exon.exon_end
                        });
                    } else {
                        // Update existing exon with additional repeat info
                        const existingExon = exonMap.get(exonKey);
                        
                        // Check if we already have this repeat region
                        const hasRepeat = existingExon.repeat_regions.some(r => 
                            r.start === repeatStart && r.end === repeatEnd);
                        
                        if (!hasRepeat) {
                            existingExon.repeat_regions.push({
                                label: repeatLabel,
                                start: repeatStart,
                                end: repeatEnd
                            });
                            
                            // Update the exon entry
                            exonMap.set(exonKey, existingExon);
                        }
                    }
                }
            }
            
            // Convert map to array and sort by exon number
            exonData.exons = Array.from(exonMap.values())
                .sort((a, b) => a.exon_number - b.exon_number);
            
            console.log(`Found ${exonData.exons.length} unique exons across all repeats`);
            
            // Only return exon data if we actually found some exons
            return exonData.exons.length > 0 ? exonData : null;
        }

        // Helper function to format phase information - just return the number
        function formatPhase(phase) {
            return phase !== undefined ? phase : 'Unknown';
        }
        
        // Helper function to format frame status
        function formatFrameStatus(status) {
            if (!status) return 'Unknown';
            if (status === 'in-frame') return 'In-frame';
            if (status === 'out-of-frame') return 'Out-of-frame';
            if (status === 'maintained') return 'Maintained';
            if (status === 'not-maintained') return 'Not maintained';
            return status;
        }

        // Function to update the exon information display
        function updateExonDisplay(exonData) {
            const exonSummary = document.getElementById('exonSummary');
            const exonDataText = document.getElementById('exonDataText');

            if (exonData && exonData.exons && exonData.exons.length > 0) {
                const transcript = exonData.transcript;
                let exonHtml = `
                    <p>Canonical transcript: <strong>${transcript.transcript_id}</strong> (${transcript.transcript_name})</p>
                    <p>Exons overlapping repeats: <strong>${exonData.exons.length}</strong></p>
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th>Exon #</th>
                                <th>Exon Boundaries</th>
                                <th>Coding Status</th>
                                <th>Start Phase</th>
                                <th>End Phase</th>
                                <th>Frame Status</th>
                                <th>Overlaps Repeats</th>
                                <th>Overlap %</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                exonData.exons.forEach(exon => {
                    // Format the repeats this exon overlaps
                    const repeatLabels = exon.repeat_regions ? 
                        exon.repeat_regions.map(r => r.label).join(", ") : 
                        "Unknown";
                    
                    // Format the frame status with descriptive text
                    const frameStatus = formatFrameStatus(exon.frame_status);
                    
                    // Format the phase information - just show the numbers
                    const startPhase = formatPhase(exon.start_phase);
                    const endPhase = formatPhase(exon.end_phase);
                    
                    exonHtml += `
                        <tr>
                            <td>${exon.exon_number}</td>
                            <td>${exon.repeat_start}-${exon.repeat_end}</td>
                            <td>${exon.coding_status || 'Unknown'}</td>
                            <td>${startPhase}</td>
                            <td>${endPhase}</td>
                            <td>${frameStatus}</td>
                            <td>${repeatLabels}</td>
                            <td>${exon.overlap_percentage ? exon.overlap_percentage + '%' : 'Unknown'}</td>
                        </tr>
                    `;
                });
                
                exonHtml += `
                        </tbody>
                    </table>
                `;
                
                exonDataText.innerHTML = exonHtml;
            } else {
                exonDataText.textContent = "No exon data available for this protein or the repeat regions.";
            }
        }

        // Function to log detailed information about repeat regions (for debugging)
        function logRepeatRegionsInfo(regions) {
            console.log(`Detailed repeats info for debugging:`);
            regions.forEach((repeat, index) => {
                const start = repeat.protein_start || 
                    (repeat.position && repeat.position.match(/amino acids (\d+)-(\d+)/) ? 
                    parseInt(repeat.position.match(/amino acids (\d+)-(\d+)/)[1]) : "unknown");
                
                const end = repeat.protein_end || 
                    (repeat.position && repeat.position.match(/amino acids (\d+)-(\d+)/) ? 
                    parseInt(repeat.position.match(/amino acids (\d+)-(\d+)/)[2]) : "unknown");
                
                const hasExonInfo = repeat.ensembl_exon_info ? "YES" : "NO";
                console.log(`Repeat ${index}: pos ${start}-${end}, has exon info: ${hasExonInfo}`);
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Get the UniProt ID from URL
            const urlParams = new URLSearchParams(window.location.search);
            const uniprotId = urlParams.get('id');
            
            if (!uniprotId) {
                showError("No protein ID specified");
                return;
            }
            
            // Define data URL
            const dataUrl = './all_annotated_repeats.json';
            
            // Load the JSON data
            fetchProteinData(uniprotId, dataUrl);
            
            // Add event listeners to buttons (moved outside initializeViewer)
            document.getElementById('highlightRepeatsBtn').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                highlightRepeats();
            });
            
            document.getElementById('standardViewBtn').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                showStandardView();
            });
            
            document.getElementById('zoomRepeatsBtn').addEventListener('click', function(e) {
                e.preventDefault();
                setActiveButton(this);
                zoomToRepeats();
            });
            
            document.getElementById('exonBoundariesBtn').addEventListener('click', function(e) {
                e.preventDefault();
                this.classList.toggle('active');
                if (this.classList.contains('active')) {
                    this.textContent = 'Hide Exon Boundaries';
                    showExonBoundaries();
                } else {
                    this.textContent = 'Show Exon Boundaries';
                    hideExonBoundaries();
                }
            });
        });

        // Function to show exon boundaries
        function showExonBoundaries() {
            if (!viewer) {
                console.error("Viewer not initialized");
                return;
            }
            
            console.log("Showing exon boundaries");
            
            // Use the already processed exon data
            const exonData = processedExonData;
            
            if (!exonData || !exonData.exons || !exonData.exons.length) {
                console.warn("No exon data available for this protein");
                return;
            }
            
            // Clear existing shapes and labels
            viewer.removeAllShapes();
            viewer.removeAllLabels();
            
            // Create a map to track all positions and their boundary types
            const positionMap = new Map(); // Map position to { sphere: boolean, labels: array of strings }
            
            // First pass: Collect all boundary positions and identify overlaps
            exonData.exons.forEach(exon => {
                if (!exon.repeat_start || !exon.repeat_end) return;
                
                // Add start position
                if (!positionMap.has(exon.repeat_start)) {
                    positionMap.set(exon.repeat_start, { sphere: false, labels: [] });
                }
                positionMap.get(exon.repeat_start).labels.push(`E${exon.exon_number} start`);
                
                // Add end position
                if (!positionMap.has(exon.repeat_end)) {
                    positionMap.set(exon.repeat_end, { sphere: false, labels: [] });
                }
                positionMap.get(exon.repeat_end).labels.push(`E${exon.exon_number} end`);
            });
            
            // Second pass: Add spheres and labels for each position
            for (const [position, info] of positionMap.entries()) {
                // Get atoms at this position
                const atoms = viewer.getModel().selectedAtoms({resi: position, atom: "CA"});
                
                if (atoms.length === 0) continue;
                
                // Get the first CA atom coordinates
                const atom = atoms[0];
                
                // Use different colors for spheres depending on whether it's a start, end, or both
                let sphereColor = '0x00FF00'; // Default to green (start)
                
                const hasStart = info.labels.some(l => l.includes('start'));
                const hasEnd = info.labels.some(l => l.includes('end'));
                
                if (hasStart && hasEnd) {
                    // If position has both start and end, use a different color (purple)
                    sphereColor = '0xFF00FF';
                } else if (hasEnd) {
                    // If only end, use red
                    sphereColor = '0xFF0000';
                }
                
                // Add a single sphere at this position
                viewer.addSphere({
                    center: {x: atom.x, y: atom.y, z: atom.z},
                    radius: 1.5,
                    color: sphereColor,
                    wireframe: true,
                    linewidth: 3,
                    alpha: 0.9
                });
                
                // Add labels with slight vertical offsets to avoid overlap
                info.labels.forEach((label, idx) => {
                    // Offset each label vertically to prevent overlap
                    const offset = (idx - (info.labels.length - 1) / 2) * 2;
                    
                    // Determine label color (green for start, red for end)
                    const bgColor = label.includes('start') ? '0x004400' : '0x440000';
                    
                    viewer.addLabel(label, {
                        position: {x: atom.x, y: atom.y + offset, z: atom.z},
                        backgroundColor: bgColor,
                        backgroundOpacity: 0.8,
                        fontColor: 'white',
                        fontSize: 12
                    });
                });
            }
            
            // Update legend with exon info
            updateLegendWithExons(exonData);
            
            viewer.render();
            console.log("Exon boundaries display complete");
        }

        // Helper function to hide exon boundaries
        function hideExonBoundaries() {
            if (!viewer) return;
            viewer.removeAllShapes();
            viewer.removeAllLabels();
            viewer.render();
            console.log("Exon boundaries hidden");
        }
        
        // Function to update legend with exon info
        function updateLegendWithExons(exonData) {
            const legend = document.getElementById('viewerLegend');
            
            // Remove existing exon legend items
            const existingExonItems = document.querySelectorAll('.exon-legend-item');
            existingExonItems.forEach(item => item.remove());
            
            // Add new header for exon legend section
            const exonHeader = document.createElement('div');
            exonHeader.className = 'legend-item exon-legend-item';
            exonHeader.innerHTML = '<strong>Exon Boundaries:</strong>';
            legend.appendChild(exonHeader);
            
            // Add start marker
            const startItem = document.createElement('div');
            startItem.className = 'legend-item exon-legend-item';
            const startBox = document.createElement('div');
            startBox.className = 'color-box';
            startBox.style.backgroundColor = '#00FF00';
            startItem.appendChild(startBox);
            startItem.appendChild(document.createTextNode('Exon start'));
            legend.appendChild(startItem);
            
            // Add end marker
            const endItem = document.createElement('div');
            endItem.className = 'legend-item exon-legend-item';
            const endBox = document.createElement('div');
            endBox.className = 'color-box';
            endBox.style.backgroundColor = '#FF0000';
            endItem.appendChild(endBox);
            endItem.appendChild(document.createTextNode('Exon end'));
            legend.appendChild(endItem);
            
            // Add combined marker
            const bothItem = document.createElement('div');
            bothItem.className = 'legend-item exon-legend-item';
            const bothBox = document.createElement('div');
            bothBox.className = 'color-box';
            bothBox.style.backgroundColor = '#FF00FF';  // Purple
            bothItem.appendChild(bothBox);
            bothItem.appendChild(document.createTextNode('Exon start & end (shared position)'));
            legend.appendChild(bothItem);
        }

        // Add toggle function for collapsible sections
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const button = event.currentTarget;
            
            if (section.classList.contains('collapsed')) {
                section.classList.remove('collapsed');
                button.textContent = 'Hide';
            } else {
                section.classList.add('collapsed');
                button.textContent = 'Show';
            }
        }
    </script>
</body>
</html>